# 数据结构

## 数组
	一系列连续的内存储存数据
	空间紧凑
	高级语言一般自带
	查询容易，插入和删除难

## 链表
	序列形的数据结构
	数据值+指向下一个的指针
	基础的数据结构(一些文件的存储模式就是链表)
	查询困难，插入和删除容易

	- 单链表
		只有指向下一个的指针
	- 双链表
		有指向下一个的指针，也有指向上一个的指针
	- 循环链表
		链表最后一个元素的指针指向第一个元素

	插入、删除、查找、更新
		复杂度均为O(N)

## 堆栈和队列

	- 堆栈(垃圾堆?)
		先进后出，后进先出
		操作
			投入push
			拿出pop
			查看待取元素peek

	- 队列
		先进先出
		操作
			入队enqueue
			出队dequeue
			查看最前端元素peek
			满否isFull
			空否isEmpty
		循环队列(求余操作实现Index循环)灵活运用空间

	数组和链表实现

## 哈希表
	以键值对的方式存储数据(Python的字典)
	找、删、增的复杂度均为O(1)
	"拉链法"实现，数组(存储哈希值)指向链表，链表的节点是键值对

	- 哈希函数
		能快速将一个数值转换成一个哈希值(本质是int)
		哈希值不同，原始输入不同
		若不同输入得到同样的哈希值->哈希值冲突
			冲突时使用链表
		哈希值与数组长度取余，节省空间
		python中hash()可以计算字符串的哈希值

	- 操作
		add增加键值对
		get通过键找到值
		remove通过键删除键值对
		getSize键值对数量
		isEmpty是否空

## 树
	一个节点连接多个节点
	数据库很多基于树实现

	- 二叉树(经典)
		每个节点最多含有两个子节点
	- 满二叉树
		二叉树中，不是尾节点(leaf)的节点都有把两个子节点
	- 完全二叉树
		一个深度d的二叉树(d > 1)，除d层，其他各层节点数量均达最大值，且d层节点左向右紧密排列
	- 排序二叉树(二分查找树)
		二叉树中，每个节点的数值比左子树上的每个节点都大，又比右子树上的每个都小
		即root元素大小处于中间位
	- 平衡二叉树
		任何节点的两颗子树的高度差不大于1的排序二叉树
	- B树
		平衡的多叉树(子节点超过2个)
	- 红黑树
		一种自平衡二叉寻找树

	- 操作
		前序遍历
			先访问节点自身，再访问左子树，最后访问右子树
		中序遍历
			先访问左子树，再访问节点自身，最后访问右子树
			用这种方法遍历排序二叉树时，可以从小到大遍历
		后序遍历
			先访问左子树，再访问右子树，最后访问节点自身
			自底向上

		可使用迭代方法实现

## 优先队列和堆
	- 优先队列
		head指向优先级最高的元素(值最大)

		操作
			push插入新元素
			pop取出优先级最高的元素
			peek查看优先级最高的元素

	- 堆(heap)
		是一种平衡二叉树
		用于优化优先队列中的push，降低复杂度
		有max heap和min heap

		操作
			insert加入新元素
				在堆的最后新建一个节点，该节点与父节点比较，若该节点较大则交换位置
				直至父节点较大或者成为根节点
			poll移除根节点
				移除后将最后的节点设为根节点，然后该节点不断进行父子节点间的比较
				直至平衡
			peek查询根节点数值

## 图(Graph)
	表示连接数据的一种数据结构

	- 无向图
		每个顶点和其他顶点通过相连线连接
	- 有向图
		连接线有方向(关注的关系)
	- 权重图
		连接线有各自的权重(反应程度深浅)

	- 矩阵实现有向图(二维数组)
		存在重复储存的现象，空间复杂度很大
	- 链表实现有向图
		相连的存于同一个链表

	- 操作(也适用于二叉树)
		深度优先遍历(DeepFirstSearch)
			先一条道走到黑，再换路
			选一个节点访问到底，再换相邻的未访问节点访问到底，重复到完全访问
		广度优先遍历(BreadthFirstSearch)
			先访问最近的子节点，同步深入